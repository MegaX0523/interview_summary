<!-- ## 
<details>
    <summary>展开</summary>

</details> -->

# C++

## template
<details>
    <summary>展开</summary>

好的，我们来详细介绍一下 C++ 中的 `template`（模板）。

**核心概念：泛型编程**

模板是 C++ 支持**泛型编程**的核心机制。所谓泛型编程，就是编写与数据类型无关的代码。简单来说，模板允许你定义一个函数或类，其中的某些类型（或值）是**参数化**的。编译器会根据你在使用模板时提供的具体类型（或值）来生成实际的函数或类代码。

**为什么需要模板？**

想象一下，你需要写一个函数来比较两个值的大小并返回较大的那个。如果没有模板，你可能需要为不同的数据类型写多个几乎相同的函数：

```cpp
int max(int a, int b) { return (a > b) ? a : b; }
double max(double a, double b) { return (a > b) ? a : b; }
std::string max(const std::string& a, const std::string& b) { return (a > b) ? a : b; }
// ... 为每个需要的类型都要写一个
```

这带来了大量的代码重复和维护负担。模板解决了这个问题：

```cpp
template <typename T> // T 是一个占位符类型
T max(T a, T b) {
    return (a > b) ? a : b;
}
```

现在，一个 `max` 模板函数就能处理所有定义了 `>` 操作符的类型（如 `int`, `double`, `std::string` 等）。

**模板的分类**

模板主要分为两大类：

1.  **函数模板 (Function Templates):**
    *   定义了一个通用函数的框架，其参数类型或返回值类型是参数化的。
    *   **语法：**
        ```cpp
        template <typename T1, typename T2, ...> // 模板参数列表
        return_type function_name(parameters) {
            // 函数体，可以使用 T1, T2 等类型
        }
        ```
    *   **`typename` 或 `class`：** 在模板参数列表中，`typename` 和 `class` 关键字在表示类型参数时是等价的（`class` 在这里不代表类，只是表示一个类型占位符）。现代 C++ 更倾向于使用 `typename` 以避免歧义。
    *   **实例化：** 当你使用函数模板时，编译器会根据你传递的实际参数类型（或你显式指定的类型）自动推导出模板参数 `T`，并生成一个处理该具体类型的函数版本（称为模板实例化）。
        ```cpp
        int i = max(10, 20);      // 实例化 max<int>(int, int)
        double d = max(3.14, 2.71); // 实例化 max<double>(double, double)
        std::string s = max("apple", "banana"); // 实例化 max<std::string>(std::string, std::string)
        ```

2.  **类模板 (Class Templates):**
    *   定义了一个通用类的框架，其成员变量类型、成员函数参数/返回值类型、甚至基类类型可以是参数化的。
    *   **语法：**
        ```cpp
        template <typename T, int Size, ...> // 模板参数列表 (可以有类型参数和非类型参数)
        class ClassName {
        public:
            // 成员函数可以使用 T, Size 等
            void someFunction(T param);
            T getValue();
        private:
            T data[Size]; // 使用类型参数 T 和非类型参数 Size
            // ...
        };
        ```
    *   **实例化：** 使用类模板时，必须在类名后面用尖括号 `<>` **显式指定**模板参数。
        ```cpp
        std::vector<int> intVector;       // 实例化一个存储 int 的 vector 类
        std::list<std::string> stringList; // 实例化一个存储 string 的 list 类
        Array<double, 100> doubleArray;    // 假设有自定义 Array 模板，存储 double，大小为 100
        ```

**模板参数的类型**

模板参数不仅仅是类型：

1.  **类型参数 (Type Parameters)：** 最常见，使用 `typename` 或 `class` 声明。代表某种数据类型。
    *   `template <typename T>`
    *   `template <class Key, class Value>`
2.  **非类型参数 (Non-type Parameters)：** 代表一个具体的值，而不是类型。必须是：
    *   整型或枚举类型（`int`, `char`, `long`, `enum` 等）
    *   指针类型（指向对象或函数的指针）
    *   左值引用类型（指向对象或函数的引用）
    *   C++17 起支持 `auto` 作为非类型模板参数的类型占位符（推导规则有限制）。
    *   该值必须是**编译时常量**。
    *   `template <int Size>`
    *   `template <typename T, int MaxSize>`
    *   `template <auto Value>` (C++17)
3.  **模板模板参数 (Template Template Parameters)：** 参数本身是一个模板。这用于需要接受另一个模板作为参数的高级场景。
    *   `template <template <typename> class Container>`

**模板实例化 (Instantiation)**

模板本身并不是一个可以直接调用的函数或一个可以直接创建对象的类。它只是一个蓝图。当你实际使用模板（调用函数模板或创建类模板对象）时，编译器会根据你提供的模板参数生成一个特定版本的函数或类。这个过程称为**实例化**。

*   **隐式实例化：** 最常见。编译器根据使用上下文自动推导模板参数并生成代码（如函数模板调用）。
*   **显式实例化：** 你可以明确告诉编译器为特定的模板参数组合生成代码，即使你还没有使用它。这可以用于控制编译时间或分离编译。
    ```cpp
    template int max<int>(int, int); // 显式实例化 max 函数用于 int
    template class std::vector<double>; // 显式实例化 vector 类用于 double
    ```

**模板特化 (Template Specialization)**

有时，模板的通用实现可能对某些特定的类型或值组合不太合适或效率不高。模板特化允许你为这些特定的参数提供定制的实现。

1.  **全特化 (Full Specialization)：** 为模板的所有参数都指定具体的类型或值。
    ```cpp
    // 通用 max 模板
    template <typename T>
    T max(T a, T b) { ... }

    // 全特化版本：针对 const char* 类型
    template <>
    const char* max<const char*>(const char* a, const char* b) {
        return (strcmp(a, b) > 0) ? a : b; // 使用 strcmp 比较字符串内容
    }
    ```
2.  **偏特化 (Partial Specialization)：** 只为模板的部分参数指定具体的类型或值（类模板特有，函数模板不支持偏特化，但可以通过重载实现类似效果）。
    ```cpp
    // 通用类模板
    template <typename T>
    class MyVector { ... };

    // 偏特化版本：针对指针类型 T*
    template <typename T>
    class MyVector<T*> { ... }; // 为指针类型提供不同的实现
    ```

**模板元编程 (Template Metaprogramming - TMP)**

利用模板在编译时进行计算和类型操作的技术。它基于模板特化、递归实例化等机制，可以在编译时生成常量、执行条件判断、进行类型转换等。TMP 非常强大但也非常复杂。

```cpp
// 编译时计算阶乘的简单例子
template <int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> { // 特化终止条件
    static const int value = 1;
};

int main() {
    int x = Factorial<5>::value; // x = 120, 在编译时计算
}
```

**优点：**

*   **代码重用：** 避免为不同类型编写几乎相同的代码。
*   **类型安全：** 比 C 的 `void*` 宏等泛型机制更安全，编译器会进行类型检查。
*   **性能：** 生成的代码是专门针对特定类型的，通常没有运行时开销（不同于虚函数或运行时类型信息）。
*   **强大的库构建：** STL (Standard Template Library) 是模板强大威力的最佳证明，它提供了泛型的容器、算法和迭代器。

**缺点/挑战：**

*   **编译时间：** 模板实例化会增加编译时间，尤其是在大型项目中或模板使用非常复杂时。
*   **错误信息：** 模板相关的编译错误信息往往冗长且难以理解（尤其是在深层嵌套或复杂实例化时）。
*   **代码膨胀：** 为不同的模板参数生成不同的代码可能导致最终可执行文件变大（但现代编译器和链接器有优化措施）。
*   **学习曲线：** 理解和熟练使用高级模板特性（如 SFINAE, 概念 C++20）需要时间和经验。

**总结：**

C++ 模板是泛型编程的基石，它极大地提高了代码的复用性、类型安全性和性能。理解函数模板和类模板的基本概念、实例化过程以及特化是掌握 C++ 现代编程的关键。虽然它带来了一些挑战（如编译时间和错误信息），但其带来的好处在构建大型、高效、可维护的软件系统时是无可替代的。STL 就是模板强大能力的最好例证。随着 C++ 标准的演进（如 C++11/14/17/20 引入的 `auto`、可变参数模板、概念等），模板的功能和易用性也在不断提升。
</details>


## 虚函数
<details>
    <summary>展开</summary>

好的，我们来深入探讨 C++ 中的虚函数（Virtual Functions）。这是面向对象编程（OOP）中实现**运行时多态（Runtime Polymorphism）** 的核心机制。

**核心概念：多态（Polymorphism）**

多态是指“一个接口，多种实现”。在 C++ 中，它允许你通过基类的指针或引用来调用派生类中重写的函数。这意味着，即使你不知道指针或引用具体指向哪个派生类对象，程序也能在运行时（而不是编译时）决定调用哪个类的函数版本。

**为什么需要虚函数？**

想象一下一个图形库，有基类 `Shape` 和派生类 `Circle`、`Rectangle`、`Triangle`。每个形状都需要计算面积，但计算方法不同。

*   **没有虚函数（静态绑定/早绑定）：**
    ```cpp
    class Shape {
    public:
        double area() { return 0.0; } // 基类实现，可能无意义
    };

    class Circle : public Shape {
    public:
        double area() { return 3.14 * radius * radius; } // 派生类实现
        double radius;
    };

    // ... 其他派生类类似

    int main() {
        Circle c;
        Rectangle r;
        Shape* s1 = &c;
        Shape* s2 = &r;

        std::cout << s1->area() << std::endl; // 输出: 0.0 (调用 Shape::area())
        std::cout << s2->area() << std::endl; // 输出: 0.0 (调用 Shape::area())
    }
    ```
    问题：通过基类指针 `s1` 和 `s2` 调用 `area()`，调用的始终是基类 `Shape` 的 `area()`，而不是实际对象（`Circle` 或 `Rectangle`）的 `area()`。这是因为在编译时，编译器根据指针的类型（`Shape*`）决定了调用哪个函数（`Shape::area()`）。

*   **使用虚函数（动态绑定/晚绑定）：**
    ```cpp
    class Shape {
    public:
        virtual double area() { return 0.0; } // 声明为虚函数
    };

    class Circle : public Shape {
    public:
        double area() override { return 3.14 * radius * radius; } // 重写虚函数 (override 可选但推荐)
        double radius;
    };

    // ... 其他派生类类似

    int main() {
        Circle c;
        Rectangle r;
        Shape* s1 = &c;
        Shape* s2 = &r;

        std::cout << s1->area() << std::endl; // 输出: Circle 的面积 (调用 Circle::area())
        std::cout << s2->area() << std::endl; // 输出: Rectangle 的面积 (调用 Rectangle::area())
    }
    ```
    关键变化：将基类的 `area()` 声明为 `virtual`。现在，通过基类指针调用 `area()` 时，程序会在**运行时**根据指针**实际指向的对象类型**（`Circle` 或 `Rectangle`）来决定调用哪个 `area()` 版本。这就是运行时多态。

**虚函数的工作原理：虚函数表（vtable）和虚指针（vptr）**

C++ 编译器实现运行时多态的核心机制是：

1.  **虚函数表（Virtual Table - vtable）：**
    *   编译器为**每个包含虚函数的类**（以及它的派生类）创建一个 `vtable`。
    *   `vtable` 是一个在**编译时**构建的静态数组（通常存在于程序的只读数据段）。
    *   数组中的每个元素是一个指向该类**虚函数实现**的函数指针。
    *   基类的 `vtable` 包含指向其虚函数实现的指针。
    *   派生类的 `vtable` 通常包含：
        *   继承自基类的虚函数指针（如果派生类没有重写，则指向基类的实现；如果重写了，则指向派生类的实现）。
        *   派生类自己定义的虚函数指针（按声明顺序）。
        *   指向 `type_info` 对象的指针（用于 `typeid` 和 `dynamic_cast`）。

2.  **虚指针（Virtual Pointer - vptr）：**
    *   编译器为**每个包含虚函数的类的对象**添加一个隐藏的成员变量，称为 `vptr`（通常位于对象内存布局的开头）。
    *   当一个对象被创建时（通过构造函数），它的 `vptr` 被初始化为指向**该对象所属类**的 `vtable`。
        *   在构造基类部分时，`vptr` 指向基类的 `vtable`。
        *   在构造派生类部分时，`vptr` 被修改为指向派生类的 `vtable`（这是为什么在构造函数中调用虚函数可能不会如你预期工作的原因）。
    *   析构过程类似（顺序相反），`vptr` 在析构函数中被调整回指向当前正在被析构的类的 `vtable`。

**调用过程：**

当通过一个**基类指针或引用**调用一个虚函数时（例如 `shapePtr->area()`），编译器会生成类似以下的代码：

1.  通过对象的 `vptr` 找到该对象所属类的 `vtable`。
2.  在 `vtable` 中找到要调用的虚函数（如 `area`）对应的函数指针（`vtable` 中函数的顺序是固定的）。
3.  通过这个函数指针调用正确的函数实现（`Circle::area()` 或 `Rectangle::area()`）。

这个过程发生在运行时，因此称为**动态绑定（Dynamic Binding）** 或 **晚绑定（Late Binding）**。

**关键语法和规则：**

1.  **声明虚函数：** 在基类中，使用 `virtual` 关键字声明函数。
    ```cpp
    class Base {
    public:
        virtual void func(); // 声明为虚函数
    };
    ```
2.  **重写虚函数：** 在派生类中，提供一个具有**相同签名**（函数名、参数列表、const 限定符）的函数。
    *   使用 `override` 关键字（C++11 引入）是**强烈推荐**的做法：
        ```cpp
        class Derived : public Base {
        public:
            void func() override; // 明确表示重写基类虚函数
        };
        ```
    *   `override` 的好处：
        *   **清晰意图：** 明确告诉编译器和人这是要重写虚函数。
        *   **编译器检查：** 如果基类没有 `virtual` 函数或签名不匹配，编译器会报错，防止因拼写错误或参数变化导致的意外隐藏而非重写。
3.  **纯虚函数和抽象类：**
    *   **纯虚函数：** 在基类中声明但没有提供实现的虚函数。语法是在声明后加 `= 0`。
        ```cpp
        class Shape {
        public:
            virtual double area() const = 0; // 纯虚函数
        };
        ```
    *   **抽象类：** 包含至少一个纯虚函数的类。
        *   抽象类**不能**被实例化（不能创建对象）。
        *   它的作用是定义接口，强制要求派生类必须实现这些纯虚函数。
        *   派生类只有实现了基类所有的纯虚函数，才能成为**具体类（Concrete Class）**，才能被实例化。
4.  **虚析构函数：**
    *   **极其重要！** 如果一个类**可能**会被继承，并且**可能**会通过基类指针来删除派生类对象，那么基类的析构函数**必须**声明为 `virtual`。
    ```cpp
    class Base {
    public:
        virtual ~Base() { /* ... */ } // 虚析构函数
    };

    class Derived : public Base {
    public:
        ~Derived() override { /* ... */ } // 派生类析构函数
    };

    int main() {
        Base* ptr = new Derived();
        delete ptr; // 正确：因为 ~Base() 是虚函数，会先调用 ~Derived()，再调用 ~Base()
    }
    ```
    *   如果基类析构函数不是虚函数，那么 `delete ptr;` 只会调用基类 `Base` 的析构函数，而不会调用派生类 `Derived` 的析构函数，导致派生类资源泄漏（内存、文件句柄等）。

**虚函数的限制与注意事项：**

1.  **构造函数不能是虚函数：** 对象在构造过程中类型是变化的（从基类到派生类），`vptr` 也在逐步设置，此时虚函数机制无法正常工作。
2.  **静态成员函数不能是虚函数：** 静态函数属于类本身，而非特定对象，没有 `this` 指针，因此无法通过 `vptr` 和 `vtable` 进行动态绑定。
3.  **友元函数不能是虚函数：** 友元函数不是类的成员函数。
4.  **内联虚函数：** `virtual` 和 `inline` 不是互斥的。编译器可以在知道对象确切类型时（如通过对象本身调用，而非指针/引用）对虚函数进行内联优化。但在通过基类指针/引用调用时，内联通常无法进行，因为具体类型在运行时才确定。
5.  **性能开销：**
    *   **空间开销：** 每个对象增加一个 `vptr`（通常 4/8 字节），每个类需要存储一个 `vtable`。
    *   **时间开销：** 通过指针/引用调用虚函数比调用普通函数或静态绑定的成员函数稍慢，因为需要额外的间接寻址（查找 `vptr` -> 查找 `vtable` -> 调用函数指针）。在现代 CPU 上，这个开销通常很小，但在性能极度敏感的代码中可能需要考虑。
6.  **在构造函数和析构函数中调用虚函数：**
    *   在构造函数中调用虚函数：调用的是**当前正在构造的类**的版本（即基类构造函数调用基类的虚函数，即使它构造的是派生类对象的一部分），而不是最终派生类的版本。因为此时派生类部分尚未完全构造，`vptr` 指向的是当前类的 `vtable`。
    *   在析构函数中调用虚函数：调用的是**当前正在析构的类**的版本（即派生类析构函数调用派生类的虚函数，基类析构函数调用基类的虚函数）。因为当进入基类析构函数时，派生类部分已经被销毁，`vptr` 已被修改为指向基类的 `vtable`。

**总结：**

*   **目的：** 虚函数是实现 C++ 运行时多态的核心，允许通过基类指针/引用调用派生类实现的函数。
*   **机制：** 基于虚函数表（`vtable`）和虚指针（`vptr`）实现动态绑定。
*   **语法：** 基类函数用 `virtual` 声明，派生类函数用相同签名重写，推荐使用 `override`。
*   **纯虚函数：** `= 0`，强制派生类实现，定义抽象类接口。
*   **虚析构函数：** 基类析构函数必须声明为 `virtual` 以确保通过基类指针删除派生类对象时正确调用派生类析构函数。
*   **开销：** 有空间（`vptr`, `vtable`）和时间（间接调用）开销，但通常是值得的。
*   **限制：** 构造函数不能是虚函数；在构造/析构函数中调用虚函数需谨慎（调用的是当前类的版本）。

理解虚函数是掌握 C++ 面向对象编程和多态性的关键。它使得设计灵活、可扩展的系统成为可能，是构建大型软件框架和库（如 GUI 框架、游戏引擎）的基础技术之一。
</details>

## STL容器
<details>
    <summary>展开</summary>

好的，我们来详细介绍一下 C++ 标准模板库 (STL) 中的各种容器及其特点。STL 容器是用于存储和管理数据集合的类模板，是 C++ 编程中最核心和实用的组件之一。

**核心分类：**

STL 容器主要分为四大类：

1.  **序列容器 (Sequence Containers):** 元素按线性顺序排列，位置取决于插入的时间和地点。
2.  **关联容器 (Associative Containers):** 元素按特定顺序（通常是键值）**排序**。查找、插入和删除操作通常具有对数时间复杂度。
3.  **无序关联容器 (Unordered Associative Containers):** 元素**不按特定顺序排序**，而是根据哈希值组织在桶中。查找、插入和删除操作平均情况下具有常数时间复杂度。
4.  **容器适配器 (Container Adapters):** 基于其他容器（如 `deque` 或 `list`）提供特定接口（如栈、队列、优先队列）。

---

### 一、序列容器 (Sequence Containers)

1.  **`std::vector` (向量)**
    *   **底层结构：** **动态数组**。在连续的内存块中存储元素。
    *   **特点：**
        *   **快速随机访问：** 通过索引 (`[]` 或 `at()`) 访问任意元素的时间复杂度是 **O(1)**。
        *   **尾部操作高效：** 在末尾添加 (`push_back`) 或删除 (`pop_back`) 元素的时间复杂度**平均是 O(1)**（有时需要重新分配内存和复制）。
        *   **头部/中间操作低效：** 在开头或中间插入/删除元素需要移动后续元素，时间复杂度是 **O(n)**。
        *   **内存管理：** 当容量不足时，会自动分配更大的内存块（通常是当前大小的 1.5 或 2 倍），复制所有元素并释放旧内存。`capacity()` 返回当前分配的内存大小，`size()` 返回实际元素个数。`reserve()` 可以预先分配内存以避免多次重新分配。
        *   **迭代器：** 提供**随机访问迭代器** (支持 `+`, `-`, `[]` 等操作)。
    *   **适用场景：** 需要快速随机访问、频繁在尾部增删元素、元素数量相对稳定或变化不剧烈（避免频繁重新分配）的场景。是**最常用**的序列容器。
    *   **注意：** 插入/删除操作可能导致指向容器内元素的**迭代器、指针和引用失效**（尤其是在引起重新分配时）。

2.  **`std::list` (双向链表)**
    *   **底层结构：** **双向链表**。每个元素（节点）包含数据和指向前后节点的指针。
    *   **特点：**
        *   **任意位置插入/删除高效：** 在已知位置（通过迭代器）插入或删除元素的时间复杂度是 **O(1)**。不需要移动其他元素。
        *   **随机访问低效：** 访问第 n 个元素需要从头或尾遍历，时间复杂度是 **O(n)**。
        *   **内存开销：** 每个元素需要额外的空间存储前后指针（空间开销比 `vector` 大）。
        *   **迭代器：** 提供**双向迭代器** (支持 `++`, `--`，但不支持 `+`, `-`, `[]`)。
        *   **特殊操作：** 支持高效的 `splice`（在常数时间内移动链表片段）、`merge`（合并有序链表）、`sort`（成员函数排序，通常比 `std::sort` 算法对链表更高效）。
    *   **适用场景：** 需要频繁在任意位置（尤其是中间）插入或删除元素，且对随机访问要求不高的场景。
    *   **注意：** 插入/删除操作**不会使指向其他元素的迭代器、指针或引用失效**（只影响被操作的元素本身的迭代器）。

3.  **`std::forward_list` (单向链表) (C++11)**
    *   **底层结构：** **单向链表**。每个元素（节点）包含数据和指向下一个节点的指针。
    *   **特点：**
        *   与 `list` 类似，但**只支持单向遍历**（只能从前往后）。
        *   **内存开销更小：** 比 `list` 少一个指针的空间开销。
        *   **迭代器：** 提供**前向迭代器** (只支持 `++`)。
        *   **没有 `size()` 成员函数：** 为了节省空间，标准不要求它存储大小。获取大小需要遍历，时间复杂度 O(n)。
        *   **插入/删除操作：** 通常在指定元素*之后*进行操作（如 `insert_after`, `erase_after`）。
    *   **适用场景：** 需要极简内存开销、只需单向遍历、频繁在任意位置（尤其是中间）插入或删除元素的场景。使用频率低于 `list`。

4.  **`std::deque` (双端队列)**
    *   **底层结构：** **分段的、大小固定的连续数组**。通常实现为一个中央控制器（索引数组）指向多个固定大小的块（页）。
    *   **特点：**
        *   **双端操作高效：** 在**开头 (`push_front`, `pop_front`) 和结尾 (`push_back`, `pop_back`)** 添加或删除元素的时间复杂度**平均是 O(1)**。
        *   **随机访问高效：** 通过索引访问元素的时间复杂度是 **O(1)**（虽然比 `vector` 稍慢一点，因为需要计算在哪个块）。
        *   **中间操作低效：** 在中间插入/删除元素需要移动元素，时间复杂度是 **O(n)**。
        *   **内存管理：** 重新分配时通常只需分配新的块并更新中央控制器，不需要复制所有元素（比 `vector` 的重新分配开销小）。内存不是完全连续的（块内连续，块间不一定连续）。
        *   **迭代器：** 提供**随机访问迭代器**。
    *   **适用场景：** 需要高效地在两端添加或删除元素，并且需要随机访问的场景。常用于实现队列 (`std::queue`) 的默认底层容器。
    *   **注意：** 插入/删除操作可能导致**所有**迭代器失效（因为可能引起中央控制器或块的重新分配）。指针和引用通常只在被操作的块内元素移动时失效。

5.  **`std::array` (数组) (C++11)**
    *   **底层结构：** **固定大小的数组**。封装了 C 风格数组，提供 STL 容器接口。
    *   **特点：**
        *   **固定大小：** 大小在编译时确定，构造后不能改变。
        *   **内存连续：** 元素存储在连续内存中。
        *   **高效：** 随机访问 O(1)，无动态内存分配开销（栈或静态存储）。
        *   **安全：** 提供 `at()` 进行边界检查（越界抛出异常），`[]` 不检查。
        *   **迭代器：** 提供**随机访问迭代器**。
        *   **支持赋值：** 整个数组可以通过 `=` 赋值（C 风格数组不行）。
    *   **适用场景：** 需要固定大小、高性能、栈上分配的数组。替代 C 风格数组的更安全、更方便的选择。
    *   **注意：** 没有 `push_back`, `pop_back`, `insert`, `erase` 等改变大小的操作。

---

### 二、关联容器 (Associative Containers)

这些容器基于**键 (Key)** 存储元素，元素按**键**自动排序（默认 `<` 运算符，可自定义比较函数）。通常实现为**红黑树** (Red-Black Tree)，一种自平衡二叉搜索树。

1.  **`std::set` (集合)**
    *   **元素：** 键本身也是值。每个元素是唯一的 (`key == value`)。
    *   **特点：**
        *   **元素唯一：** 集合中不允许重复元素。
        *   **有序：** 元素按键值自动排序。
        *   **查找高效：** 查找 (`find`, `count`)、插入 (`insert`)、删除 (`erase`) 的时间复杂度均为 **O(log n)**。
        *   **迭代器：** 提供**双向迭代器**。遍历时元素按排序顺序输出。
    *   **适用场景：** 需要存储唯一元素、需要按顺序遍历、需要快速检查元素是否存在。

2.  **`std::multiset` (多重集合)**
    *   **元素：** 键本身也是值 (`key == value`)。
    *   **特点：**
        *   与 `set` 类似，但**允许重复元素**。
        *   查找、插入、删除的时间复杂度也是 **O(log n)**。
    *   **适用场景：** 需要存储可能重复的元素、需要按顺序遍历、需要快速查找。

3.  **`std::map` (映射)**
    *   **元素：** 键值对 (`key-value pair`)。每个元素包含一个唯一的键 (Key) 和一个关联的值 (Value)。
    *   **特点：**
        *   **键唯一：** 每个键只能在 `map` 中出现一次。
        *   **按键排序：** 元素按键值自动排序。
        *   **查找高效：** 通过键查找值 (`operator[]`, `find`, `count`)、插入 (`insert`, `operator[]`)、删除 (`erase`) 的时间复杂度均为 **O(log n)**。
        *   **迭代器：** 提供**双向迭代器**。遍历时元素按键排序顺序输出。迭代器指向 `std::pair<const Key, Value>`。
    *   **适用场景：** 需要建立键到值的唯一映射关系、需要按键排序遍历、需要通过键快速查找值。是**最常用**的关联容器之一。

4.  **`std::multimap` (多重映射)**
    *   **元素：** 键值对 (`key-value pair`)。
    *   **特点：**
        *   与 `map` 类似，但**允许键重复**（一个键可以对应多个值）。
        *   查找、插入、删除的时间复杂度也是 **O(log n)**。
    *   **适用场景：** 需要建立键到值的一对多映射关系、需要按键排序遍历、需要通过键查找值（可能得到多个结果）。

---

### 三、无序关联容器 (Unordered Associative Containers) (C++11)

这些容器基于**哈希表 (Hash Table)** 实现。元素根据其键的**哈希值 (Hash Value)** 存储在**桶 (Bucket)** 中。查找、插入和删除的平均时间复杂度是常数 O(1)，最坏情况是 O(n)（所有元素哈希冲突到同一个桶）。**元素不按特定顺序排序**。

1.  **`std::unordered_set` (无序集合)**
    *   **元素：** 键本身也是值 (`key == value`)。
    *   **特点：**
        *   **元素唯一：** 不允许重复元素。
        *   **无序：** 元素不按特定顺序存储（顺序取决于哈希函数和桶）。
        *   **平均高效：** 查找 (`find`, `count`)、插入 (`insert`)、删除 (`erase`) 的平均时间复杂度是 **O(1)**。
        *   **依赖哈希函数：** 性能高度依赖于哈希函数的质量和桶的数量。可以通过 `load_factor()` 和 `max_load_factor()` 管理负载因子（元素数/桶数），使用 `rehash()` 或 `reserve()` 调整桶的数量以优化性能。
        *   **迭代器：** 提供**前向迭代器**。
    *   **适用场景：** 需要存储唯一元素、需要最快速度的查找/插入/删除、不关心元素顺序。

2.  **`std::unordered_multiset` (无序多重集合)**
    *   **元素：** 键本身也是值 (`key == value`)。
    *   **特点：**
        *   与 `unordered_set` 类似，但**允许重复元素**。
        *   查找、插入、删除的平均时间复杂度也是 **O(1)**。
    *   **适用场景：** 需要存储可能重复的元素、需要最快速度的查找/插入/删除、不关心元素顺序。

3.  **`std::unordered_map` (无序映射)**
    *   **元素：** 键值对 (`key-value pair`)。
    *   **特点：**
        *   **键唯一：** 每个键只能出现一次。
        *   **无序：** 元素按键的哈希值存储。
        *   **平均高效：** 通过键查找值 (`operator[]`, `find`, `count`)、插入 (`insert`, `operator[]`)、删除 (`erase`) 的平均时间复杂度是 **O(1)**。
        *   **依赖哈希函数：** 性能同样依赖于哈希函数和桶的管理。
        *   **迭代器：** 提供**前向迭代器**。迭代器指向 `std::pair<const Key, Value>`。
    *   **适用场景：** 需要建立键到值的唯一映射关系、需要最快速度的查找/插入/删除、不关心键的顺序。是**最常用**的无序容器之一。

4.  **`std::unordered_multimap` (无序多重映射)**
    *   **元素：** 键值对 (`key-value pair`)。
    *   **特点：**
        *   与 `unordered_map` 类似，但**允许键重复**。
        *   查找、插入、删除的平均时间复杂度也是 **O(1)**。
    *   **适用场景：** 需要建立键到值的一对多映射关系、需要最快速度的查找/插入/删除、不关心键的顺序。

---

### 四、容器适配器 (Container Adapters)

这些不是完整的容器，而是在其他底层容器（默认为 `deque`）之上提供特定接口的包装器。

1.  **`std::stack` (栈)**
    *   **接口：** 提供 **LIFO (Last-In, First-Out)** 接口：`push` (入栈), `pop` (出栈), `top` (访问栈顶元素)。
    *   **底层容器：** 默认使用 `deque`。也可以指定为 `vector` 或 `list` (`std::stack<T, std::vector<T>>`)。底层容器需要支持 `back()`, `push_back()`, `pop_back()`。
    *   **适用场景：** 需要后进先出语义的场景，如函数调用栈、撤销操作、深度优先搜索 (DFS)。

2.  **`std::queue` (队列)**
    *   **接口：** 提供 **FIFO (First-In, First-Out)** 接口：`push` (入队), `pop` (出队), `front` (访问队首元素), `back` (访问队尾元素)。
    *   **底层容器：** 默认使用 `deque`。也可以指定为 `list` (`std::queue<T, std::list<T>>`)。底层容器需要支持 `front()`, `back()`, `push_back()`, `pop_front()`。（`vector` 不支持 `pop_front()`，所以不能直接用作 `queue` 的底层容器）。
    *   **适用场景：** 需要先进先出语义的场景，如任务调度、消息队列、广度优先搜索 (BFS)。

3.  **`std::priority_queue` (优先队列)**
    *   **接口：** 提供类似队列的接口，但元素不是按插入顺序，而是按**优先级**出队。`top()` 访问优先级最高的元素（队首），`pop()` 移除它。`push()` 插入元素。
    *   **底层容器：** 默认使用 `vector`。也可以使用 `deque`。底层容器需要支持随机访问迭代器、`front()`, `push_back()`, `pop_back()`。
    *   **排序：** 元素按**比较函数对象**（默认为 `std::less<T>`，形成最大堆/大顶堆）排序。可以自定义比较函数来改变优先级顺序（例如 `std::greater<T>` 形成最小堆/小顶堆）。
    *   **实现：** 通常基于**堆 (Heap)** 数据结构（二叉堆）实现。
    *   **操作复杂度：** `push()` 和 `pop()` 的时间复杂度是 **O(log n)**。`top()` 是 **O(1)**。
    *   **适用场景：** 需要快速访问和移除当前最大（或最小）元素的场景，如任务调度（优先级高的先执行）、哈夫曼编码、Dijkstra 最短路径算法。

---

### 总结与选择建议

*   **默认序列容器：** **`std::vector`**。除非有特殊需求（如频繁在头部/中间插入删除，则考虑 `list`/`forward_list`；或频繁在两端操作，则考虑 `deque`）。
*   **需要快速查找 (O(log n)) 和排序：** **`std::set`** (唯一元素) / **`std::map`** (键值对)。
*   **需要最快查找 (平均 O(1))，不关心顺序：** **`std::unordered_set`** (唯一元素) / **`std::unordered_map`** (键值对)。
*   **栈/队列语义：** **`std::stack`** / **`std::queue`**。
*   **需要优先级队列：** **`std::priority_queue`**。
*   **固定大小数组：** **`std::array`** (替代 C 数组)。
*   **键可重复：** 使用 `multi` 版本 (`multiset`, `multimap`, `unordered_multiset`, `unordered_multimap`)。

选择容器时，务必考虑操作（插入、删除、查找、遍历）的频率和位置（头部、尾部、中间、任意位置），以及对内存、性能（时间复杂度）、元素顺序的要求。理解底层数据结构是做出明智选择的关键。

</details>