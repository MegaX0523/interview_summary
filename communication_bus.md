<!-- ## 
<details>
    <summary>展开</summary>

</details> -->

# 通信总线相关

## I2C
<details>
    <summary>展开</summary>

### 一、I2C 是什么？

I2C（Inter-Integrated Circuit），中文常译为**集成电路总线**，是由飞利浦公司（现恩智浦 NXP）在1980年代开发的一种简单、双向、二线制、同步串行通信总线。

它的主要设计目的是为了一块电路板（PCB）上的**集成电路（IC）之间**提供一种简单、高效的通信方式。由于其简洁性，它至今仍然是连接微控制器（MCU）、传感器、存储器、IO扩展器、实时时钟（RTC）等外围设备的主流标准。

---

### 二、I2C 的主要特点

1.  **仅需两根线**：这是其最大的优势，极大地节省了宝贵的芯片引脚和PCB走线空间。
    *   **SDA（Serial Data Line）**：串行数据线，用于双向传输数据。
    *   **SCL（Serial Clock Line）**：串行时钟线，由主设备产生，用于同步数据传输。
2.  **多主多从架构**：理论上，总线上可以连接多个**主设备（Master）** 和多个**从设备（Slave）**。主设备负责发起和控制通信，从设备响应主设备的请求。常见的是一主多从结构。
3.  **软件寻址**：每个连接到I2C总线的从设备都有一个**唯一的7位或10位地址**。主设备通过发送这个地址来选择要与哪个从设备通信，无需额外的片选线。
4.  **速度模式**：
    *   **标准模式（Standard-mode）**：100 kbit/s
    *   **快速模式（Fast-mode）**：400 kbit/s
    *   **高速模式（High-speed mode）**：3.4 Mbit/s
    *   **超快速模式（Ultra Fast-mode）**：5 Mbit/s
5.  **半双工通信**：数据可以在SDA线上双向传输，但同一时刻只能有一个方向的数据流。

---

### 三、硬件连接方式

所有设备都**并联**在总线上，结构非常简洁：
*   **SDA** 和 **SCL** 两条线都需要通过**上拉电阻**连接到正电源（Vcc）。这是因为I2C总线使用的是**开漏输出（Open-Drain）** 机制。开漏输出只能将线路拉低（输出0），而不能主动输出高电平。当总线空闲时，上拉电阻确保线路处于高电平（1）。任何设备需要输出时，只需将线路拉低即可。

这种设计也带来了一个好处：**实现了“线与”功能**，即只要有一个设备将总线拉低，整条线就是低电平，这为**时钟同步**和**仲裁**提供了硬件基础。

---

### 四、通信流程与数据格式

一次完整的I2C通信通常包含以下几个步骤：

1.  **起始条件（START Condition）**：当SCL为高电平时，SDA线从高电平跳变到低电平。这个信号由主设备发出，表示一次传输的开始。
2.  **发送地址帧（Address Frame）**：主设备发送一个7位或10位的从设备地址，后面紧跟一个**读写位（R/W#）**。
    *   **0**：表示主设备要**写入**（发送数据给）从设备。
    *   **1**：表示主设备要**读取**（从设备接收）数据。
3.  **应答位（ACK/NACK）**：每传输完一个字节（8位）的数据（包括地址字节），接收方必须发送一个应答信号。
    *   **ACK（Acknowledge）**：接收方将SDA线拉低，表示成功收到了一个字节。
    *   **NACK（Not Acknowledge）**：接收方不拉低SDA线（保持高电平），通常表示接收失败或传输结束。
4.  **数据帧（Data Frames）**：在地址得到应答后，开始传输数据字节。每个数据字节后同样跟随一个ACK/NACK位。数据可以持续传输多个字节。
5.  **停止条件（STOP Condition）**：当SCL为高电平时，SDA线从低电平跳变到高电平。这个信号由主设备发出，表示本次传输结束。

**一个典型的“主设备向从设备写数据”的时序图：**
```
[S] [Addr (W)] [ACK] [Data 1] [ACK] [Data 2] [ACK] ... [Data N] [ACK/NACK] [P]
```
*   `S`: 起始条件
*   `P`: 停止条件

---

### 五、优点与缺点

**优点：**
*   **引脚少，布线简单**：只需要两根线，极大地简化了硬件设计。
*   **支持多主设备**（虽然不常用）：通过仲裁机制避免数据冲突。
*   **有成熟的协议和广泛的业界支持**：几乎所有微控制器都内置I2C控制器，外围芯片种类丰富。

**缺点：**
*   **速度相对较慢**：与SPI等总线相比，速度是其短板。
*   **通信距离短**：通常用于板级通信（几十厘米内），不适合长距离传输。
*   **软件实现较复杂**：虽然硬件简单，但协议时序需要精确控制。不过现在大多由硬件控制器处理。
*   **上拉电阻值需要选择**：电阻值需要根据总线速度和总线电容进行计算，以满足上升时间要求。

---

### 总结

| 特性 | 描述 |
| :--- | :--- |
| **全称** | Inter-Integrated Circuit |
| **线数** | 2根（SDA， SCL） |
| **通信方式** | 串行、同步、半双工 |
| **架构** | 多主多从（常用一主多从） |
| **寻址方式** | 软件寻址（7位或10位地址） |
| **速度** | 标准：100kbps， 快速：400kbps， 高速：3.4Mbps |
| **关键机制** | 开漏输出+上拉电阻、起始/停止条件、ACK/NACK |

总而言之，I2C是一种在**短距离、中低速、设备众多**的应用场景下非常经济高效的通信解决方案，是嵌入式工程师必须掌握的核心通信协议之一。
</details>

## SPI
<details>
    <summary>展开</summary>

SPI（Serial Peripheral Interface，串行外设接口）是一种高速、全双工、同步的串行通信总线，由摩托罗拉（Motorola）公司开发。它广泛用于微控制器（MCU）与传感器、存储器、显示屏等外围设备之间的短距离通信。

| 特性         | SPI                                                                                              | I2C（对比参考）                                   |
| :----------- | :--------------------------------------------------------------------------------------------------- | :------------------------------------------------- |
| **通信方式**   | 全双工                                                                        | 半双工                                             |
| **线数**     | 4根（SCK, MOSI, MISO, SS/CS）                                                        | 2根（SDA, SCL）                                    |
| **拓扑结构**   | 一主多从（常用），每个从设备独立片选线                                                       | 多主多从，所有设备挂接在同一总线上                       |
| **寻址方式**   | 硬件片选（SS/CS线）                                                               | 软件地址（7位或10位地址）                            |
| **最高速率**   | 可达几十MHz                                                                                  | 标准模式100kbps，快速模式400kbps                    |
| **协议复杂度** | 硬件接口简单，协议灵活                                                               | 协议相对复杂，有起始、停止、应答等信号                |
| **优势**     | 高速、全双工、协议灵活、简单高效                                                | 引脚少、支持多主控、有应答机制                      |
| **劣势**     | 无标准协议、无硬件流控与应答、无错误检查、占用引脚多（尤其多从机时）、传输距离短 | 速度相对较慢、协议更复杂、通信距离短                 |

接下来，我们详细了解SPI总线的几个核心方面。

### 硬件连接与信号线

一个SPI系统通常包含一个主设备（Master）和一个或多个从设备（Slave），通过以下**4条信号线**连接：

*   **SCK (Serial Clock) - 串行时钟**：由主设备产生，用于同步数据传输。
*   **MOSI (Master Out Slave In) - 主设备数据输出，从设备数据输入**：主设备通过这条线向从设备发送数据。
*   **MISO (Master In Slave Out) - 主设备数据输入，从设备数据输出**：从设备通过这条线向主设备发送数据。
*   **SS/CS (Slave Select/Chip Select) - 片选信号**：由主设备控制，用于选择要通信的从设备，**低电平有效**。当主设备需要与某个从设备通信时，会将对应从设备的SS线拉低。

连接多个从设备时，SCK、MOSI、MISO通常所有设备并联，而每个从设备都需要一个独立的SS线连接到主设备。

### 工作原理与数据传输

SPI通信基于**主从模式**和**移位寄存器**原理：

1.  **发起通信**：主设备通过拉低目标从设备的**SS/CS**线来选择它。
2.  **提供时钟**：主设备在**SCK**线上产生时钟信号。
3.  **同步传输**：在时钟同步下：
    *   主设备通过**MOSI**线将数据位移发送给从设备。
    *   从设备通过**MISO**线将数据位移发送给主设备。
    *   每个时钟周期，主设备和从设备**同时交换一个比特位**，完成全双工通信。传输通常**高位（MSB）在前**。
4.  **结束通信**：传输完成后，主设备将**SS/CS**线拉高，结束本次通信。

SPI的数据传输无需指定固定格式，数据帧长度和内容可由应用自行定义，非常灵活。

### 时钟模式 (CPOL与CPHA)

SPI有**4种时钟模式**，由**时钟极性（CPOL, Clock Polarity）** 和**时钟相位（CPHA, Clock Phase）** 共同决定：

*   **CPOL**：规定SCK线在空闲状态时的电平。
    *   `CPOL=0`：SCK空闲时为**低电平**。
    *   `CPOL=1`：SCK空闲时为**高电平**。
*   **CPHA**：规定在时钟的**第几个边沿**进行数据采样。
    *   `CPHA=0`：在时钟的**第一个边沿**（若CPOL=0，则为上升沿；CPOL=1，则为下降沿）采样数据。
    *   `CPHA=1`：在时钟的**第二个边沿**（若CPOL=0，则为下降沿；CPOL=1，则为上升沿）采样数据。

主设备和从设备必须使用相同的时钟模式才能正常通信。

| 模式 | CPOL | CPHA | 时钟空闲态 | 数据采样时刻 (对接收方) | 数据变化时刻 (对发送方) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 0 | 0 | 0 | 低电平 | 第一个边沿 (上升沿) | 第二个边沿 (下降沿) |
| 1 | 0 | 1 | 低电平 | 第二个边沿 (下降沿) | 第一个边沿 (上升沿) |
| 2 | 1 | 0 | 高电平 | 第一个边沿 (下降沿) | 第二个边沿 (上升沿) |
| 3 | 1 | 1 | 高电平 | 第二个边沿 (上升沿) | 第一个边沿 (下降沿) |

### 优点

SPI总线广泛流行，主要得益于其以下优点：
*   **高速传输**：速率可达几十MHz，远高于I2C等协议。
*   **全双工通信**：可同时收发数据，数据吞吐率高。
*   **协议简单灵活**：硬件接口简单，数据帧格式和长度可灵活定义。
*   **无需复杂寻址**：通过硬件片选，无需I2C那样的地址分配和冲突仲裁。
*   **推挽输出**：信号完整性好，开关速度快。

### 缺点

SPI也存在一些固有的缺点：
*   **无硬件流控与应答机制**：主设备无法通过协议确认从设备是否成功接收数据。
*   **占用较多I/O引脚**：每增加一个从设备，主设备就需多占用一个I/O引脚用于片选。
*   **无标准协议规范**：不同厂家产品可能存在差异，兼容性有时需注意。
*   **通信距离短**：通常用于PCB板内或近距离设备间通信。
*   **多数情况下仅支持单主设备**。

### 总结

SPI凭借其**高速、全双工、协议简单灵活**的特点，在**短距离、板级设备间**通信中非常受欢迎。虽然它在多设备连接时需要更多引脚，并且缺乏硬件流控和应答机制，但在许多注重速度和实时性的应用场景中，它仍然是优先选择的方案。
</details> 

## USB
<details>
    <summary>展开</summary>

USB（Universal Serial Bus，通用串行总线）是现代计算和电子设备中不可或缺的串行总线标准，主要用于连接主机和外部设备。

| **协议版本** | **推出时间** | **最大理论速率** | **编码方式**       | **关键特性**                                                                 |
| :----------- | :----------- | :--------------- | :----------------- | :--------------------------------------------------------------------------- |
| USB 1.0      | 1996年       | 1.5 Mbps (Low Speed) |                    | 支持热插拔                                                             |
| USB 1.1      | 1998年       | 12 Mbps (Full Speed) |                    | 成功替代串口和并口                                                     |
| USB 2.0      | 2000年       | 480 Mbps (High Speed) |                    | 支持OTG（On-The-Go）                                                    |
| USB 3.0      | 2008年       | 5 Gbps           | 8b/10b             | 全双工传输，提高能效                                            |
| USB 3.1 Gen 2 | 2013年       | 10 Gbps          | 128b/132b          |                                                                              |
| USB 3.2      | 2017年       | 20 Gbps          |                    | 双通道传输                                                             |
| USB4         | 2019年       | 40 Gbps          |                    | 基于Thunderbolt 3协议，支持动态分配带宽                          |

### 数据传输机制

USB 总线采用**轮询**机制，由主机（Host）主动发起所有数据传输请求和控制。一次完整的数据传输（称为**事务**）通常包含三个包：令牌包（Token Packet）、数据包（Data Packet）和握手包（Handshake Packet）。

USB 协议定义了 **4 种基本传输类型**，以适应不同的应用场景和数据需求：

| **传输类型** | **应用场景**                                   | **数据可靠性** | **典型数据负载（字节）** | **特点**                                                                 |
| :----------- | :--------------------------------------------- | :------------- | :----------------------- | :----------------------------------------------------------------------- |
| **控制传输** | 设备枚举、配置、命令传输（Endpoint 0） | 高，有握手机制   | 高速设备可达8-64         | 每个USB设备都必须支持，用于管理。                                    |
| **批量传输** | U盘、打印机、大容量存储          | 高，有差错重传   |                          | 利用空闲带宽传输，无传输速率保证，但数据必须准确无误。                       |
| **中断传输** | 键盘、鼠标                       | 高             |                          | 用于非周期的、自然发生的、数据量很小的信息的传输。                             |
| **同步传输** | 摄像头、音频设备（实时流）                 | 低，无差错重传   | 高速设备可达1024        | 为保持实时性，允许一定的数据错误或丢失，适用于对延迟敏感、对错误不敏感的场景。 |

### 物理连接与电气特性

USB 电缆内部通常包含以下导线：
*   **VBUS（+5V电源线）**：为设备供电。
*   **D+（数据正线）** & **D-（数据负线）**：采用**差分信号**传输数据，抗干扰能力更强。
*   **GND（地线）**：提供参考电平。

USB 2.0 及以下版本使用单对差分数据线（D+, D-），而 USB 3.0 及以上版本在保留这对线以兼容 USB 2.0 的同时，增加了额外的差分对（如 SSTX+/SSTX- 和 SSRX+/SSRX-）来实现超高速（SuperSpeed）数据收发。

USB **没有独立的时钟线**，接收端通过**时钟恢复技术**从数据信号中提取时钟信号以实现同步。

### 通信与协议细节

**1. 数据包结构**
USB 数据传输的基本单元是**包（Packet）**。 一个 USB 数据包通常由以下字段组成：
*   **同步字段（SYNC）**：用于接收端时钟同步。
*   **包标识符（PID）**：指明包的类型（如令牌、数据、握手）。
*   **数据字段**：承载实际的有效载荷。
*   **循环冗余校验（CRC）**：用于错误检测。
*   **包结尾（EOP）**：标记包的结束。

**2. 设备枚举**
当 USB 设备插入主机时，主机会执行一个名为**枚举（Enumeration）** 的过程：
1.  检测设备连接。
2.  复位设备。
3.  读取设备的**描述符**（包括设备描述符、配置描述符、接口描述符、端点描述符等），这些描述符详细说明了设备的属性、能力和需求。
4.  为设备分配一个唯一的地址。
5.  加载合适的设备驱动程序（如果系统已有其驱动）。
枚举完成后，主机就可以根据描述符的信息与设备进行正常的数据通信了。

**3. USB OTG (On-The-Go)**
USB OTG 是 USB 标准的扩展，允许设备（如手机、平板）在**主机（Host）** 和**外设（Device）** 角色间动态切换。例如，支持 OTG 的手机可以充当主机直接读取 U 盘里的数据，而无需通过电脑。


### 关键硬件组件

USB 系统的主要硬件组件包括：
*   **主机控制器 (Host Controller)**：负责管理 USB 总线上的通信，包括设备枚举、数据传输调度、错误处理等。
*   **集线器 (Hub)**：用于扩展 USB 接口数量的特殊设备。它监视端口的信号电压变化以检测设备连接和移除，并能处理不同速度等级（高速/全速/低速）的设备。
*   **设备 (Device)**：实现特定功能的USB外设，如U盘、鼠标等。

### 信号编码与位填充

USB 使用 **NRZI (Non-Return to Zero Inverted) 编码**：
*   **数据位为 `1` 时，信号电平不发生翻转**。
*   **数据位为 `0` 时，信号电平发生翻转**。
*   为保证信号有足够的跳变用于接收端时钟同步，当连续发送 **6 个 `1`** 时，发送端会自动**插入一个 `0`**（位填充），接收端则会**移除这个填充位**。

### 时钟恢复技术

USB **没有独立的时钟线**。接收端需从数据流中**提取时钟信号**，这个过程称为**时钟恢复**。

1.  **同步码 (SYNC Field) 引导**：所有 USB 数据包都以一个固定的**同步码**（如 00000001）开始。接收端检测到这个已知的位模式后，会利用其规律的跳变来**调整本地时钟的相位和频率**，实现与发送端的初步同步。

2.  **持续同步与时钟调整**：同步码之后，接收端依赖数据流中 NRZI 编码产生的**电平跳变（对应数据 `0`）** 来不断微调本地时钟，保持同步。时钟恢复电路（如基于 PLL 或数字控制逻辑的电路）的核心任务就是**产生一个与输入数据流频率和相位锁定的时钟信号**。

3.  **时钟恢复电路实例**：一种实现方案包含**内置振荡器模块**（如电流饥饿型环形振荡器，其振荡频率由输入电流控制）和**数字控制逻辑模块**。
    *   数字控制逻辑模块会**检测主机发送的同步码**，并**比较内置振荡器的频率与数据流速率**。
    *   根据比较结果（如对同步码特定位的持续时间进行计数判断），电路会发出“加速”或“减速”信号，通过调整电流镜的放大倍数来改变振荡器的工作电流，从而**精确调节其输出频率**，使其与数据流速率匹配。

### 端点与数据传输

*   **端点 (Endpoint)**：是 USB 设备中进行数据收发的**最小单元**，本质上是设备内的一个**数据缓冲区**。每个端点有唯一地址和传输特性（如输入、输出）。除默认端点（端点0）外，低速设备最多支持2组端点，高速和全速设备最多可支持15组端点。
*   **事务 (Transaction)**：一次完整的数据交互（如 IN、OUT、SETUP）通常由**令牌包**（指示事务类型和地址）、**数据包**（可选）和**握手包**（可选，用于应答）构成。
</details>

## MODBUS
<details>
    <summary>展开</summary>

| 特性维度         | 具体说明                                                                                              |
| :--------------- | :---------------------------------------------------------------------------------------------------- |
| **核心架构**     | **主从（Master-Slave）架构**，单主设备发起请求，多从设备响应。 |
| **通信模式**     | **请求-响应（Request-Response）**。 |
| **物理层与介质** | **RS-232**、**RS-485**、**以太网**等，支持双绞线、光纤、无线等多种介质。 |
| **数据模型**     | **4种数据类型**：线圈（Coils）、离散输入（Discrete Inputs）、输入寄存器（Input Registers）、保持寄存器（Holding Registers）。 |
| **功能码**       | **定义操作类型**，如读线圈（0x01）、读保持寄存器（0x03）、写单个寄存器（0x06）、写多个寄存器（0x10）等。 |
| **传输模式**     | **Modbus RTU**（二进制，高效）、**Modbus ASCII**（文本，可读性好）、**Modbus TCP**（基于以太网）。 |
| **优势**         | 标准开放（免许可费）、简单易用、支持厂商和设备众多。 |

### 物理层与传输模式

Modbus 协议可以运行在多种物理介质上，主要通过三种模式传输：

1.  **Modbus RTU (Remote Terminal Unit)**：
    *   **编码方式**：采用**二进制**格式传输数据，通信效率高。
    *   **物理接口**：通常基于 **RS-485**（支持多设备、长距离）或 **RS-232**（点对点）。
    *   **校验机制**：使用 **CRC-16** 循环冗余校验确保数据完整性。
    *   **帧格式**：`[从站地址] [功能码] [数据] [CRC校验]`。

2.  **Modbus ASCII**：
    *   **编码方式**：使用**ASCII字符**表示十六进制数据，可读性好但效率较低（同样数据内容传输时间约为RTU的两倍）。
    *   **校验机制**：采用 **LRC**（纵向冗余校验）。
    *   **帧格式**：以冒号 `:` 起始，以回车换行符 `<CR><LF>` 结束。

3.  **Modbus TCP**：
    *   **网络基础**：基于 **TCP/IP** 协议，通常使用 **502 端口**。
    *   **数据封装**：在 Modbus PDU（协议数据单元）前添加 **MBAP 报文头**（7字节），用于事务标识、协议标识、长度和单元标识等。
    *   **优势**：支持更远的距离、更快的速度（以太网速率），并可融入更复杂的网络拓扑。

### 通信模型与过程

Modbus 采用严格的**主从式通信**：
*   **主设备（Master）**：主动发起请求，如工控机、PLC或网关。
*   **从设备（Slave）**：被动响应请求，如传感器、执行器、智能仪表。

一次完整的**请求-响应**通信流程如下：
1.  **主设备发送请求**：主设备构建一个请求帧，包含从站地址、功能码、数据域（如寄存器地址、数量）和错误校验码。
2.  **从设备处理请求**：对应地址的从设备接收请求，解析功能码，并执行相应的操作（如读取传感器数据或改变输出状态）。
3.  **从设备返回响应**：从设备返回一个响应帧，包含确认的功能码、请求的数据或执行状态。如果处理过程中发生错误，则返回一个异常响应（功能码最高位置1，并附加异常码）。
4.  **主设备处理响应**：主设备接收响应，进行校验和解析。如果收到异常响应，则进行相应的错误处理。

主设备还可以使用**广播地址**（通常是0）向所有从设备发送命令（通常是写操作），此时从设备不会回复响应。

### 数据模型与功能码

Modbus 协议抽象了四种数据类型，并定义了相应的功能码对其进行读写操作。

| **数据类型** | **读写属性** | **位宽** | **逻辑地址范围** | **功能码示例** | **典型应用** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **线圈 (Coils)** | 读写 | 1位 | 00001-09999 | 0x01: 读多个线圈<br>0x05: 写单个线圈<br>0x0F: 写多个线圈 | 继电器、开关输出 |
| **离散输入 (Discrete Inputs)** | 只读 | 1位 | 10001-19999 | 0x02: 读离散输入 | 按钮、开关状态输入 |
| **输入寄存器 (Input Registers)** | 只读 | 16位 | 30001-39999 | 0x04: 读输入寄存器 | 温度、压力等传感器数据 |
| **保持寄存器 (Holding Registers)** | 读写 | 16位 | 40001-49999 | 0x03: 读保持寄存器<br>0x06: 写单个保持寄存器<br>0x10: 写多个保持寄存器 | 设备参数、设定值 |

### 错误处理

Modbus 提供了简单的错误检测和异常响应机制：
*   **校验码**：RTU模式使用**CRC校验**，ASCII模式使用**LRC校验**，用于检测传输过程中的数据错误。
*   **异常响应**：如果从设备无法处理主设备的请求（如非法功能码、非法数据地址），它会返回一个异常响应帧。该帧将原功能码的最高位置1（即原功能码 + 0x80），并附加一个异常码，指示错误原因。

---

### 通信过程
典型的 Modbus RTU 通信场景：**主设备（例如 PLC）读写从设备（例如一个智能温控器）的保持寄存器（Holding Registers）**。

**场景设定：**

*   **从设备地址 (Slave Address)：** `0x01` (十进制 1)
*   **功能码 (Function Code)：**
    *   读多个保持寄存器：`0x03`
    *   写单个保持寄存器：`0x06`
    *   写多个保持寄存器：`0x10`
*   **寄存器地址 (Register Address)：** Modbus 保持寄存器的逻辑地址范围是 40001-49999。在协议帧中，我们使用从 `0` 开始的偏移量（或称为“寄存器地址”）。
    *   例如，逻辑地址 `40001` 对应的寄存器地址是 `0x0000` (十六进制 0)。
    *   逻辑地址 `40100` 对应的寄存器地址是 `0x0063` (十六进制 99, 因为 100 - 1 = 99)。
*   **数据：** 假设温控器的设定温度存储在保持寄存器 `40001` (地址 `0x0000`)。我们想：
    1.  **读取** 当前设定温度（假设存储在 1 个寄存器中）。
    2.  **写入** 一个新的设定温度值 `25°C` 到同一个寄存器。
    3.  **写入** 一组参数（例如上限 `30°C` 和下限 `15°C`）到寄存器 `40002` (地址 `0x0001`) 和 `40003` (地址 `0x0002`)。


### 示例 1：主设备读取保持寄存器 (功能码 `0x03`)

*   **主设备请求帧 (Master Request)：**
    *   目标：读取从站 `0x01` 的 1 个保持寄存器，起始地址为 `40001` (地址 `0x0000`)。
    *   **帧结构：** `[Slave Addr] [Func Code] [Start Addr Hi] [Start Addr Lo] [Reg Qty Hi] [Reg Qty Lo] [CRC Lo] [CRC Hi]`
    *   **具体字节：**
        ```
        0x01,     // 从站地址 = 1
        0x03,     // 功能码 = 读多个保持寄存器
        0x00,     // 起始寄存器地址高字节 = 0
        0x00,     // 起始寄存器地址低字节 = 0 (地址 0x0000 = 40001)
        0x00,     // 寄存器数量高字节 = 0
        0x01,     // 寄存器数量低字节 = 1 (读1个寄存器)
        0x84,     // CRC 校验码低字节 (计算值)
        0x0A      // CRC 校验码高字节 (计算值)
        ```
    *   **说明：** CRC 值 (`0x840A`) 是根据前面 6 个字节 (`01 03 00 00 00 01`) 计算出来的。

*   **从设备响应帧 (Slave Response)：**
    *   假设当前设定温度值为 `20°C` (十六进制 `0x0014`)。
    *   **帧结构：** `[Slave Addr] [Func Code] [Byte Count] [Data Hi] [Data Lo] ... [CRC Lo] [CRC Hi]`
    *   **具体字节：**
        ```
        0x01,     // 从站地址 = 1
        0x03,     // 功能码 = 读多个保持寄存器 (与请求一致)
        0x02,     // 字节数 = 2 (因为读了1个寄存器，每个寄存器2字节)
        0x00,     // 数据高字节 (寄存器值高8位)
        0x14,     // 数据低字节 (寄存器值低8位) = 0x0014 = 20
        0x31,     // CRC 校验码低字节 (计算值)
        0xCA      // CRC 校验码高字节 (计算值)
        ```
    *   **说明：** CRC 值 (`0x31CA`) 是根据前面 5 个字节 (`01 03 02 00 14`) 计算出来的。主设备收到后需校验 CRC 并解析数据 `0x0014` 得到温度值 20。


### 示例 2：主设备写入单个保持寄存器 (功能码 `0x06`)

*   **主设备请求帧 (Master Request)：**
    *   目标：将值 `25°C` (十六进制 `0x0019`) 写入从站 `0x01` 的保持寄存器 `40001` (地址 `0x0000`)。
    *   **帧结构：** `[Slave Addr] [Func Code] [Reg Addr Hi] [Reg Addr Lo] [Data Hi] [Data Lo] [CRC Lo] [CRC Hi]`
    *   **具体字节：**
        ```
        0x01,     // 从站地址 = 1
        0x06,     // 功能码 = 写单个保持寄存器
        0x00,     // 寄存器地址高字节 = 0
        0x00,     // 寄存器地址低字节 = 0 (地址 0x0000 = 40001)
        0x00,     // 写入数据高字节 = 0
        0x19,     // 写入数据低字节 = 0x19 (25)
        0x98,     // CRC 校验码低字节 (计算值)
        0x4A      // CRC 校验码高字节 (计算值)
        ```
    *   **说明：** CRC 值 (`0x984A`) 根据前 6 个字节 (`01 06 00 00 00 19`) 计算。

*   **从设备响应帧 (Slave Response)：**
    *   成功写入后，从设备**原样返回**主设备的请求帧作为响应（这是功能码 `0x06` 的规定）。
    *   **具体字节：**
        ```
        0x01,     // 从站地址 = 1
        0x06,     // 功能码 = 写单个保持寄存器
        0x00,     // 寄存器地址高字节 = 0
        0x00,     // 寄存器地址低字节 = 0
        0x00,     // 数据高字节 = 0
        0x19,     // 数据低字节 = 0x19 (25)
        0x98,     // CRC 校验码低字节 (与请求相同)
        0x4A      // CRC 校验码高字节 (与请求相同)
        ```
    *   **说明：** 主设备收到此响应，并与自己发送的请求比较，如果一致则认为写入成功。同样需要校验 CRC。


### 示例 3：主设备写入多个保持寄存器 (功能码 `0x10`)

*   **主设备请求帧 (Master Request)：**
    *   目标：将值 `30°C` (`0x001E`) 和 `15°C` (`0x000F`) 分别写入从站 `0x01` 的保持寄存器 `40002` (地址 `0x0001`) 和 `40003` (地址 `0x0002`)。
    *   **帧结构：** `[Slave Addr] [Func Code] [Start Addr Hi] [Start Addr Lo] [Reg Qty Hi] [Reg Qty Lo] [Byte Count] [Data Hi] [Data Lo] ... [CRC Lo] [CRC Hi]`
    *   **具体字节：**
        ```
        0x01,     // 从站地址 = 1
        0x10,     // 功能码 = 写多个保持寄存器
        0x00,     // 起始寄存器地址高字节 = 0
        0x01,     // 起始寄存器地址低字节 = 1 (地址 0x0001 = 40002)
        0x00,     // 寄存器数量高字节 = 0
        0x02,     // 寄存器数量低字节 = 2 (写2个寄存器)
        0x04,     // 字节数 = 4 (2个寄存器 * 2字节/寄存器)
        0x00,     // 寄存器1数据高字节 (30°C 高8位)
        0x1E,     // 寄存器1数据低字节 (30°C 低8位) = 0x001E
        0x00,     // 寄存器2数据高字节 (15°C 高8位)
        0x0F,     // 寄存器2数据低字节 (15°C 低8位) = 0x000F
        0x12,     // CRC 校验码低字节 (计算值)
        0x74      // CRC 校验码高字节 (计算值)
        ```
    *   **说明：** CRC 值 (`0x1274`) 根据前 11 个字节 (`01 10 00 01 00 02 04 00 1E 00 0F`) 计算。

*   **从设备响应帧 (Slave Response)：**
    *   成功写入后，从设备返回一个**确认帧**，包含起始地址和写入的寄存器数量。
    *   **帧结构：** `[Slave Addr] [Func Code] [Start Addr Hi] [Start Addr Lo] [Reg Qty Hi] [Reg Qty Lo] [CRC Lo] [CRC Hi]`
    *   **具体字节：**
        ```
        0x01,     // 从站地址 = 1
        0x10,     // 功能码 = 写多个保持寄存器
        0x00,     // 起始寄存器地址高字节 = 0
        0x01,     // 起始寄存器地址低字节 = 1
        0x00,     // 寄存器数量高字节 = 0
        0x02,     // 寄存器数量低字节 = 2
        0x91,     // CRC 校验码低字节 (计算值)
        0xCC      // CRC 校验码高字节 (计算值)
        ```
    *   **说明：** CRC 值 (`0x91CC`) 根据前 6 个字节 (`01 10 00 01 00 02`) 计算。主设备需校验 CRC 并确认起始地址和数量与自己发送的请求一致，则认为写入成功。



### 关键点总结

1.  **寄存器地址：** 在帧中使用的是 **从 0 开始的偏移量**（如 `40001` -> `0x0000`），而非逻辑地址 `40001`。
2.  **字节序：** Modbus 协议规定寄存器值按 **大端序 (Big-Endian)** 传输。高字节在前，低字节在后（如 `0x0014` 传输为 `0x00` 然后 `0x14`）。
3.  **CRC 校验：** **至关重要！** 所有 RTU 帧都包含 16 位 CRC 校验码（低字节在前）。发送方计算并附加，接收方必须重新计算并比对，不一致则丢弃该帧。
4.  **响应一致性：**
    *   `0x03` (读)：响应包含数据字节。
    *   `0x06` (写单个)：响应**回显**请求帧。
    *   `0x10` (写多个)：响应**确认**起始地址和数量。
5.  **错误响应：** 如果从设备处理请求出错（如非法地址、非法功能码），它会返回一个**异常响应**帧，将功能码最高位置 `1` (即 `原功能码 + 0x80`)，并附加一个异常码。例如，对 `0x03` 的非法地址错误响应可能是：`[0x01] [0x83] [0x02] [CRC Lo] [CRC Hi]` (`0x83` = `0x03 + 0x80`, `0x02` 表示非法数据地址异常码)。

---

</details>

## PCIE
<details>
    <summary>展开</summary>

PCIe（Peripheral Component Interconnect Express）总线是现代计算机系统中至关重要的高速串行扩展总线标准，用于连接高性能外设。

| 特性维度         | 具体说明                                                                                              |
| :--------------- | :---------------------------------------------------------------------------------------------------- |
| **核心架构**     | 点对点串行连接，基于通道（Lane）可扩展（x1, x2, x4, x8, x16, x32） |
| **分层模型**     | 事务层（Transaction Layer）、数据链路层（Data Link Layer）、物理层（Physical Layer） |
| **通信基础**     | 基于数据包（Packet）传输                                                                 |
| **关键数据包类型** | TLP（事务层包）、DLLP（数据链路层包）                                                          |
| **流控机制**     | 基于信用的流控制（Credit-Based Flow Control）                                                          |
| **错误处理**     | ECRC（端到端CRC）和LCRC（链路CRC）校验，ACK/NAK确认与重传机制                         |
| **编码方式**     | PCIe 1.x/2.0: 8b/10b; PCIe 3.0+: 128b/130b                                                |

接下来，我们深入了解PCIe协议的各个层面。

### 物理层（Physical Layer）

物理层负责处理**电气信号、编码解码和链路训练**等底层操作。
*   **通道与链路**：每个PCIe **通道（Lane）** 由**两对差分信号线**（一对发送TX，一对接收RX）组成，实现**全双工通信**。一条**链路（Link）** 可以包含1到32个这样的通道（如x1, x4, x8, x16），通道数越多，带宽越高。
*   **编码方案**：为了保证信号完整性和时钟恢复，数据在传输前会被编码：
    *   PCIe 1.x和2.0使用 **8b/10b编码**（每8位数据编码为10位传输，开销20%）。
    *   PCIe 3.0及更高版本使用 **128b/130b编码**（开销降至约1.54%），显著提升了有效带宽。
*   **链路训练**：在启动时，PCIe设备会通过交换训练序列（TS1/TS2）自动协商**链路速度、通道宽度**等参数，确保稳定连接。

### 事务层（Transaction Layer）

事务层是协议栈的最高层，负责生成和处理事务层数据包（TLP）。
*   **TLP包**：所有读写操作都被封装成**TLP（Transaction Layer Packet）**。TLP包头包含了事务类型、地址、数据长度等关键信息。
*   **事务类型**：PCIe支持多种事务类型，主要针对以下地址空间：
    *   **内存读写请求**：与CPU和设备间的数据传输密切相关。
    *   **配置读写请求**：用于枚举和配置PCIe设备。
    *   **消息事务**：用于事件通知、中断等功能。
*   **流量控制**：为了防止数据溢出，PCIe采用基于信用的流控制机制。接收端会告知发送端其可用的缓冲区空间（信用值），发送端仅在有足够信用时才会发送数据。

### 数据链路层（Data Link Layer）

数据链路层在事务层和物理层之间，确保数据可靠传输。
*   **序列号与校验**：数据链路层会为发出的TLP添加**序列号**和 **LCRC（链路循环冗余校验）** 后缀，形成**DLLP（Data Link Layer Packet）**。
*   **ACK/NAK协议**：接收端收到DLLP后，会进行LCRC校验。若校验通过，则向发送端返回**ACK**确认包；若失败或超时未收到，则返回**NAK**否认包，发送端会根据NAK或超时情况进行**重传**。这种机制确保了链路级的数据完整性。
*   **链路管理**：数据链路层还负责管理链路的激活、状态监控和电源管理等功能。

### 数据流示例

一次简单的CPU读取PCIe设备内存的数据流如下：
1.  **请求**：CPU发起读请求 -> RC的事务层生成**读请求TLP** -> 数据链路层添加序列号和LCRC -> 物理层进行编码并通过链路发送。
2.  **响应**：目标设备物理层接收并解码 -> 数据链路层校验LCRC，若正确则返回ACK，否则返回NAK -> 事务层解析TLP，准备数据。
3.  **完成**：设备的事务层生成**带数据的完成TLP** -> 同样经过数据链路层和物理层封装后发回 -> RC收到后，最终将数据返回给CPU。

若任何环节出现错误（如LCRC校验失败），数据链路层的ACK/NAK机制会触发重传。

### 版本与带宽

PCIe版本迭代主要提升传输速率（通常每代翻倍）。带宽计算公式为：
`带宽 = 传输速率 × 通道数 × 编码效率 × 2 (全双工)`

下表列出了各版本单通道（x1）的带宽（因编码方式不同，实际有效带宽需计算编码效率）：

| 版本     | 原始传输速率 (GT/s) | 编码方案   | 单通道单向带宽 (MB/s) | x16链路单向带宽 (GB/s) | x16链路双向带宽 (GB/s) |
| :------- | :------------------ | :--------- | :--------------------- | :--------------------- | :---------------------- |
| PCIe 1.0 | 2.5                 | 8b/10b     | 250                    | 4.0                    | ~8.0                    |
| PCIe 2.0 | 5.0                 | 8b/10b     | 500                    | 8.0                    | ~16.0                   |
| PCIe 3.0 | 8.0                 | 128b/130b  | ~984.6                 | ~15.75                 | ~31.5                   |
| PCIe 4.0 | 16.0                | 128b/130b  | ~1969                  | ~31.5                  | ~63.0                   |
| PCIe 5.0 | 32.0                | 128b/130b  | ~3938                  | ~63.0                  | ~126.0                  |
| PCIe 6.0 | 64.0 (PAM4)         |            | ~1260 (单向)           | ~201.6                 | ~403.2                  |

*此表数据综合自和，PCIe 6.0采用PAM4调制和FEC前向纠错。*

### 配置与地址空间

PCIe兼容PCI的软件模型，保留了其配置空间（256字节，可扩展至4KB），系统通过**配置读写事务**在启动时（枚举过程）为每个设备分配所需的资源。
*   **BAR（Base Address Register）**：每个PCIe功能都有**BAR寄存器**，用于定义其内部地址空间（如内存映射或I/O映射）在系统全局地址空间中的位置和大小。操作系统通过读取BAR并为其分配物理地址，使得CPU能够直接访问设备资源。
</details>

## CAN
<details>
    <summary>展开</summary>

CAN总线（Controller Area Network，控制器局域网）是一种非常可靠且高效的串行通信协议，特别适合在恶劣电磁环境下实现分布式实时控制。下面我将为你梳理其核心内容。

| 特性维度         | 具体说明                                                                                              |
| :--------------- | :---------------------------------------------------------------------------------------------------- |
| **核心架构**     | 多主结构（Multi-master），节点无主从之分，基于标识符（Identifier）的优先级进行通信                       |
| **物理层**       | 差分信号（CAN_H 和 CAN_L），显性电平（逻辑0）和隐性电平（逻辑1），两端需接120Ω终端电阻                     |
| **关键机制**     | 非破坏性仲裁（Non-destructive Bit-wise Arbitration）、基于消息内容（标识符ID）的寻址方式                   |
| **错误处理**     | 强大的错误检测、通知和恢复机制（CRC校验、应答、错误帧、错误计数器及节点状态管理）                         |
| **帧类型**       | 数据帧、远程帧、错误帧、过载帧、帧间隔                                                                      |
| **数据负载**     | 经典CAN：0-8字节；CAN FD：最多64字节                                                                      |
| **典型应用**     | 汽车电子、工业自动化、医疗设备、轨道交通等                                                                  |

CAN总线最初由**博世（Bosch）公司**在1980年代为汽车电子系统设计，旨在减少车辆中线束的数量和复杂度。由于其**高可靠性、实时性和抗干扰能力**，它已被广泛应用于工业自动化、医疗设备等多个领域。

### 物理层与硬件连接

CAN总线使用**双绞线**进行数据传输，主要包含两条信号线：
*   **CAN_H（高电平线）**
*   **CAN_L（低电平线）**

总线上的电平状态分为两种：
*   **显性电平（Dominant）**：表示逻辑 `0`。此时 CAN_H 电压升高（如3.5V），CAN_L 电压降低（如1.5V），两者差分电压大于阈值（如 > 0.9V）。
*   **隐性电平（Recessive）**：表示逻辑 `1`。此时 CAN_H 和 CAN_L 电压都接近平均值（如2.5V），差分电压小于阈值（如 < 0.5V）。**显性电平具有优先级**，只要总线上有一个节点输出显性电平，总线即呈现显性状态。

为了避免信号在总线末端反射造成干扰，需要在**总线两端**各接一个**120欧姆的终端电阻**，这与电缆的特性阻抗相匹配。

### 通信帧类型

CAN协议定义了**5种类型的帧**来管理通信：
1.  **数据帧（Data Frame）**：用于节点向总线上发送数据。这是最常用的帧类型。
2.  **远程帧（Remote Frame）**：用于请求另一个节点发送具有相同标识符的数据帧。
3.  **错误帧（Error Frame）**：当任何节点检测到错误时，会立即发送此帧来通知总线上的所有其他节点。
4.  **过载帧（Overload Frame）**：用于在数据帧或远程帧之间提供额外的延迟。
5.  **帧间隔（Interframe Space）**：用于分隔数据帧或远程帧与前面的帧。

数据帧主要有两种格式：
*   **标准帧（CAN 2.0A）**：使用**11位标识符**。
*   **扩展帧（CAN 2.0B）**：使用**29位标识符**（包含11位基本ID和18位扩展ID），提供了更大的地址空间。

CAN FD（Flexible Data-rate）是CAN协议的升级版本，主要改进有：
*   **更高的数据段速率**：仲裁段后可采用更高的通信速率。
*   **更长的数据场**：数据 payload 最多可达**64字节**。

### 非破坏性仲裁机制

当多个节点同时开始发送消息时：
*   节点在发送每一位的同时**监控总线电平**。
*   如果节点发送了一个**隐性位（1）**，但监测到总线上是**显性位（0）**（这意味着另一个节点正在发送优先级更高的消息），该节点会**立即停止发送**并转变为接收器。
*   **标识符（ID）值越小，优先级越高**（因为其二进制表示前有更多的显性位）。
*    **赢得仲裁的节点继续无中断地完成传输**，而仲裁失败的节点则会在总线空闲时自动重试。

### `位时序`

### 一、位时序的核心目的

CAN总线没有独立的时钟线，所有节点都使用**异步串行通信**。位时序机制的核心目的是：

1.  **实现同步**：让接收节点在正确的时刻对总线电平进行采样，以读取正确的比特位。
2.  **补偿误差**：补偿节点间晶振误差、总线传输延迟以及电磁干扰带来的相位偏差。

### 二、位时间的构成

一个比特位（1 Bit Time）在时间轴上被划分为4个不重叠的段（Segments）。这些段的时间长度由一个基本时间单位——**时间份额（Time Quantum, TQ）** 来度量。


**CAN位时间 = Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2**

---

#### 1. **同步段 (Synchronization Segment, Sync_Seg)**
*   **长度**：固定为 **1 TQ**。
*   **作用**：期望的边沿（从隐性到显性，或显性到隐性的跳变）就应该出现在这个时间段内。所有节点都以此段作为同步的基准。
*   **简单理解**：**“时钟对齐点”**。

#### 2. **传播段 (Propagation Segment, Prop_Seg)**
*   **长度**：可配置（通常为 **1~8 TQ**）。
*   **作用**：**补偿信号在总线上物理传输的延迟时间**。这个延迟包括：
    *   发送节点的输出延迟
    *   信号在总线上的传播延迟
    *   接收节点的输入延迟
*   **简单理解**：**“给信号在路上跑的时间”**。

#### 3. **相位缓冲段1 (Phase Buffer Segment 1, Phase_Seg1)**
*   **长度**：可配置（通常为 **1~8 TQ**）。
*   **作用**：**补偿节点间的晶振误差**。它可以通过**重同步**被延长或缩短。

#### 4. **相位缓冲段2 (Phase Buffer Segment 2, Phase_Seg2)**
*   **长度**：可配置（通常为 **1~8 TQ**）。
*   **作用**：同样用于**补偿节点间的晶振误差**。它可以通过**重同步**被缩短。
*   **采样点 (Sample Point)**：位于 **Phase_Seg1 结束处**（即Phase_Seg1和Phase_Seg2的交界点）。接收节点就是在这个时刻对总线电平进行采样，读取比特位的值。

---

### 三、同步机制 (Synchronization)

为了保持节点间时序一致，CAN控制器提供了两种同步方式：

#### 1. 硬同步 (Hard Synchronization)
*   **发生时机**：仅在**总线空闲后出现的第一个下降沿**（帧起始SOF位）。
*   **行为**：硬同步会**强制**将当前位时间内的Sync_Seg重新开始，不管之前进行到哪个段。
*   **目的**：让所有节点在每一帧的开始都站在同一起跑线上。

#### 2. 重同步 (Resynchronization)
*   **发生时机**：在帧传输过程中，**每次从隐性到显性的跳变边沿**（但SOF位除外）。
*   **行为**：根据边沿出现的位置，调整Phase_Seg1或Phase_Seg2的长度：
    *   如果边沿出现在采样点之前，说明发送节点频率更快，则**延长Phase_Seg1**。
    *   如果边沿出现在采样点之后，说明发送节点频率更慢，则**缩短Phase_Seg2**。
*   **目的**：在帧传输过程中不断微调，保持所有节点步调一致。

#### 3. 同步跳转宽度 (Synchronization Jump Width, SJW)
*   **定义**：**一次重同步最多可以调整的TQ数量**。这是一个可配置的参数（通常为1-4 TQ）。
*   **作用**：限制重同步的调整幅度，防止因单个尖峰脉冲干扰而导致时序过度调整。
*   **规则**：`SJW ≤ min(Phase_Seg1, Phase_Seg2)`

---

### 四、如何配置位时序（以STM32为例）

```c
hcan.Init.Prescaler = 6;                 // 预分频器，决定1个TQ的时间长度
hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;   // 同步跳转宽度 = 1 TQ
hcan.Init.TimeSeg1 = CAN_BS1_6TQ;        // (Prop_Seg + Phase_Seg1) = 6 TQ
hcan.Init.TimeSeg2 = CAN_BS2_5TQ;        // (Phase_Seg2) = 5 TQ
```

*   **波特率计算**：
    `波特率 = APB1时钟 / (Prescaler * (1 + TimeSeg1 + TimeSeg2))`
    假设APB1时钟为54MHz：  
    `波特率 = 54,000,000 / (6 * (1 + 6 + 5)) = 54,000,000 / 72 = 750 kbps`

*   **采样点计算**：
    `采样点位置 = (1 + TimeSeg1) / (1 + TimeSeg1 + TimeSeg2) * 100%`
    `采样点位置 = (1 + 6) / (1 + 6 + 5) * 100% = 7/12 ≈ 58.3%`

**工程建议**：采样点通常设置在位时间的75%~80%处，这样容错性更好。因此这个示例的58.3%偏低，可以增加`TimeSeg1`或减少`TimeSeg2`来调整。

### 位时序总结

| 关键概念 | 作用 | 配置建议 |
| :--- | :--- | :--- |
| **位时间** | 一个比特位的持续时间 | 由波特率决定 |
| **时间份额(TQ)** | 配置位时间的最小单位 | 由Prescaler和系统时钟决定 |
| **同步段** | 边沿的理想出现位置 | 固定1TQ |
| **传播段** | 补偿物理延迟 | 根据总线长度和节点延迟设置 |
| **相位缓冲段** | 补偿晶振误差，确定采样点 | 采样点建议设在75%~80% |
| **同步跳转宽度** | 限制单次重同步的最大调整量 | 通常设置为1或2 |

### `通信过程`

常见场景——​​发动机控制单元（ECU）向变速箱控制单元（TCU）发送转速数据​：

| **字段名称** | **位数** | **值（示例）** | **说明** |
| :--- | :--- | :--- | :--- |
| **帧起始 (SOF)** | 1 | `0` (显性) | 帧开始，同步所有节点。 |
| **仲裁字段** | 12 | `0x123` + `0` | 11位ID=`0x123`(优先级)，RTR=`0`(数据帧)。 |
| **控制字段** | 6 | `0` `0` `0010` | IDE=`0`(标准帧)，r0=`0`，DLC=`2`(数据长度2字节)。 |
| **数据字段** | 16 (2字节) | `0x03`, `0xE8` | 实际数据，1000转/分 = 0x03E8。 |
| **CRC字段** | 16 | - | 15位CRC校验值 + 1位隐性界定符。 |
| **ACK字段** | 2 | - | 1位ACK槽(接收方拉低) + 1位隐性界定符。 |
| **帧结束 (EOF)** | 7 | `1` `1` `1` `1` `1` `1` `1` (隐性) | 标志帧结束。 |

---

### 第一步：发送准备（ECU端）

发动机ECU需要将当前转速（1000 rpm）发送给TCU。
1.  **应用程序**将数据 `1000` 传递给底层的CAN控制器。
2.  **CAN控制器**将数据封装成帧：
    *   **标识符 (ID)**：使用预先定义好的ID `0x123` 来标识“发动机转速”这一消息。ID值较小，表示优先级较高。
    *   **数据长度码 (DLC)**：转速值用2字节（16位）表示，所以 DLC = `2`。
    *   **数据**：将1000转换为十六进制 `0x03E8`，存入数据字段。

---

### 第二步：帧发送与总线仲裁

ECU的CAN控制器开始向总线发送帧的各个字段：

1.  **帧起始 (SOF)**：首先发送1位**显性电平 (0)**。总线上所有节点检测到这个下降沿，**同步**它们的位时间。
2.  **仲裁段**：接着发送11位ID (`0x123` 的二进制形式) 和1位**RTR位**（数据帧为显性 `0`）。
    *   **假设**此时另一个节点（如ABS控制器）也在发送ID为 `0x456` 的帧。
    *   两台设备同时发送位流，并在发送的同时**监听总线电平**。
    *   当发送到ID的第3位时，`0x123` 的对应位是 `0`（显性），而 `0x456` 的对应位是 `1`（隐性）。
    *   **显性电平覆盖隐性电平**，因此ABS控制器监听到的总线电平是 `0`，与自己发送的 `1` 不符，意识到仲裁失败，**立即退出发送**转为接收模式。
    *   **ECU赢得总线使用权**，继续无损地发送剩余帧内容。这就是**非破坏性仲裁**。

---

### 第三步：帧接收与响应（全网节点）

总线上所有节点（包括目标TCU和其他ECU）都在接收这个帧：

1.  **控制段**：接收IDE=`0`（标准帧）、r0=`0`、DLC=`2`，知道接下来要接收2字节数据。
2.  **数据段**：接收2个字节的数据 `0x03E8`。
3.  **CRC段**：接收15位CRC校验码和1位隐性界定符。每个节点都用接收到的数据计算CRC，与发送来的CRC值进行比较。
4.  **ACK段**：这是确认环节。
    *   发送器在ACK槽中发送**隐性位 (1)**。
    *   **所有成功接收到该帧（CRC校验正确）的节点**（包括TCU和其他节点），会在ACK槽内回一个**显性位 (0)**，覆盖掉原来的隐性位。
    *   发送器ECU监测到ACK槽被拉低为显性电平，便知道**至少有一个节点成功接收**了此帧。如果所有节点都接收失败，ACK槽将保持隐性，发送器会知道传输失败。
5.  **帧结束 (EOF)**：接收到7个隐性位 `1`，标志此帧结束。

---

### 第四步：数据处理（TCU端）

1.  **硬件过滤**：TCU的CAN控制器内置了**接收过滤器**。它可能被设置为只接收ID为 `0x123` 的帧，因此会放过该帧并将其存入接收FIFO，而忽略其他不相关的ID帧。
2.  **中断触发**：TCU的CAN控制器产生接收中断。
3.  **软件处理**：TCU的CPU从中断服务程序(ISR)中读取接收到的数据：ID=`0x123`, Data=`0x03E8`。
4.  **数据解析**：应用程序根据协议知道 `0x03E8` 表示1000 rpm，于是TCU就可以根据这个转速值来进行相应的换挡逻辑计算。

---

### 如果数据超过8字节？——多帧传输简介

CAN一帧最多只能带8字节数据。如果要传输的数据更长（例如，升级固件时的数据包），就需要使用**多帧传输**机制（如ISO-TP协议）。

1.  **拆包**：发送端将长数据按规则切割成多个**8字节或更小**的CAN帧。
2.  **添加序列号**：在数据字段中预留字节作为**帧序号**，以便接收端按顺序重组。
3.  **流控**：接收端可以控制发送端的发送速率，防止自身缓冲区溢出。
4.  **重组**：接收端根据帧序号将所有数据包重新组合成完整的数据。

---


### 错误处理

CAN总线设计了**全面的错误检测和处理机制**：
*   **错误检测**：包括**位错误**、**填充错误**（位填充规则违反）、**CRC错误**、**格式错误**等。
*   **错误通知**：检测到错误的节点会立即发送一个**错误帧**。
*   **错误恢复**：发送失败的帧会**自动重传**。

每个CAN节点内部都有**发送错误计数器（TEC）** 和**接收错误计数器（REC）**。根据错误计数，节点会处于三种状态：
*   **错误主动（Error Active）**：可以正常参与总线通信，发现错误时发送主动错误标志。
*   **错误被动（Error Passive）**：限制其发送错误帧的能力。
*   **总线关闭（Bus Off）**：节点与总线隔离，不再参与任何通信。这是一种严重的故障状态，通常需要重启才能恢复。

</details>

## CRC校验
<details>
    <summary>展开</summary>


### 一、CRC基本概念

CRC（Cyclic Redundancy Check，循环冗余校验）是一种基于多项式除法的错误检测技术，用于检测数据传输过程中可能发生的比特错误。在CAN总线通信中，CRC是确保数据完整性的重要机制之一。

### 二、CAN总线中的CRC校验实现

### 1. CRC字段位置与结构

在CAN数据帧中，CRC校验段位于数据段之后、应答段之前，具体结构为：
- **CRC序列**：15位（标准CAN 2.0）或17/21位（CAN FD）
- **CRC界定符**：1位固定隐性位

### 2. 标准CAN 2.0的CRC参数

- **CRC长度**：15位
- **生成多项式**：CRC-15
  ```
  G(x) = x^15 + x^14 + x^10 + x^8 + x^7 + x^4 + x^3 + 1
  ```
  十六进制表示：0x4599（高位在前）或0x4A31（低位在前）

- **初始值**：全1（0x7FFF）
- **输入/输出处理**：不进行数据反转

### 3. CRC计算范围

CAN总线的CRC校验覆盖以下部分：
- 帧起始（1位）
- 仲裁段（标准帧12位/扩展帧33位）
- 控制段（6位）
- 数据段（0-64位，取决于DLC）

*注意：CRC计算不包括CRC字段本身、应答段和帧结束部分*

### 三、CRC工作原理

### **发送端计算**：
   - 节点将要发送的数据按照特定多项式进行模2除法
   - 得到15位余数作为CRC校验码
   - 将CRC校验码附加到数据帧中发送

**计算步骤：**

1.  **预处理**：在原始数据（被除数）的末尾追加 `n` 个 `0`。`n` 是CRC校验码的位数（如CRC-16是16位，就加16个0）。这个新数作为**被除数**。
2.  **除法**：将预处理后的数据作为**被除数**，与选定的**生成多项式（除数）** 进行**模2除法**。
3.  **取余数**：除法运算得到的**余数**就是**CRC校验码**。这个余数的位数一定比除数位数少1位。
4.  **组成发送数据**：用这个**余数**替换掉第一步中追加的 `n` 个 `0`，形成最终要发送的数据。

**示例：** 假设原始数据为 `1101 0110`，生成多项式为 `11001`（代表 CRC-4），计算过程如下：

```
// 步骤 1: 预处理，追加 n-1 个 0 (因为 11001 是 5 位，n=4)
原始数据: 1101 0110
追加 4 个 0: 1101 0110 0000 <- 这是新的被除数

// 步骤 2 & 3: 用 11001 对 1101 0110 0000 进行模2除法 (逐位异或)
// 计算过程略，假设最终得到余数为 0110

// 步骤 4: 组成发送帧
最终发送数据: 1101 0110 0110
              [原始数据] [CRC]
```

接收方收到 `1101 0110 0110` 后，会用同样的生成多项式 `11001` 去除它。如果传输无误，**余数应为 0**。


### **接收端验证**：
   - 接收节点对接收到的数据（包括原始数据和CRC码）执行相同的计算
   - 如果计算结果为0，则数据被认为无错误
   - 如果结果非0，则检测到传输错误，将触发错误帧

### 四、错误检测能力

CAN总线的CRC-15具有强大的错误检测能力：
- 所有单比特错误
- 所有双比特错误
- 所有奇数个比特错误
- 长度≤15的突发错误
- 大部分更长的突发错误（检测概率>99.995%）

### 五、位填充对CRC的影响

CAN协议使用"位填充"机制（连续5个相同位后插入相反位），这一机制与CRC校验协同工作：
- 位填充在CRC计算**之后**进行
- 接收端先进行位解填充，**再**进行CRC校验
- 这种设计确保位填充不会干扰CRC的错误检测能力

### 六、CAN FD中的CRC增强

随着CAN FD（Flexible Data-rate）的发展，CRC机制得到增强：
- **数据段≤16字节**：使用17位CRC（CRC-17）
  ```
  G(x) = x^17 + x^16 + x^12 + x^11 + x^10 + x^8 + x^6 + x^4 + x^2 + x + 1
  ```
- **数据段>16字节**：使用21位CRC（CRC-21）
  ```
  G(x) = x^21 + x^20 + x^18 + x^15 + x^14 + x^13 + x^12 + x^8 + x^3 + x^2 + 1
  ```

这些增强的CRC算法提供了更高的错误检测能力，以适应CAN FD更高的数据速率和更大的数据负载（最大64字节）。

### 七、CRC与其他错误检测机制的协同

CAN总线采用多重错误检测机制，CRC是其中最关键的一环，与其他机制共同工作：
- **位监控**：节点监控自己发送的位
- **帧检查**：检查帧格式是否符合规范
- **应答检查**：确保消息被至少一个其他节点正确接收
- **位填充规则检查**：检测连续6个相同位
</details>

